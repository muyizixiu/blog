---
title: unicode utf-8 and encoding
date: 2016-06-20
---
编码总是个问题，尤其是在数据历经不同平台，甚至是不同程序下！今天来捋清楚看似简单的编码问题。

**所有的编码都是指，字符以何种二进制形式存储起来！**


##### ASCII码
ASCII码是十分基础的编码，囊括了英文字母，数字和不可打印的控制字符，一共是128个。ASCII码用一个字节的存储，占用了二进制：0000 0000 -- 0111 1111 
这样的一个经典编码，对于英语国家来说或许够用了。但是我大中华上下五千年，汉字上万个，显然是一个字节的二进制是无法表达清楚的，又考虑到不同国家编码标准不一致，导致同一个二进制存储的数据对应的字符不一致。万国码，unicode码也就蛋生了！
##### unicode码
unicode码为每个字符设定了统一并且唯一的一个整数（正式说法是code），也就是说，使用了unicode码为编码规范的字符对应的二进制存储是唯一的。比如说字符“2”：对应的数字是0x32。在shell下：
```
root#  echo -e "\u32"
root#  2
```
'\u'是转义符，是指该字符的unicode码。

那么问题来了，这种unicode码的字符，对应的二进制存储是什么样的！

实际上，unicode码仅规定了字符对应的那个整数是什么！并没有规定如何存储，所以unicode码的实现方式又有很多种，这里介绍下大名鼎鼎的utf-8编码！

##### utf-8

1）对于只有一个单字节的符号，字节的第一位设为0，后面7位为这个符号的unicode码（那就是那个整数）。因此对于英语字母，UTF-8编码和ASCII码是相同的。
2）对于n字节的符号，第一个字节的前n位都设为1，第n+1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的unicode码。

utf-8实现了unicode编码规范，互联网中绝大多数平台都采用了她，而非其余的unicode编码规范。


##### 中文
在网络中，经常见到中文被转义了，变成了对应的unicode转义码，如上面的'\u32'。值得注意的是，这里不是乱码，而是被转义了。常见的一些原因是中文在某些协议中不被支持，从而转义成常见字符。
